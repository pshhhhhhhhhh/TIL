# TIL 240217 정처기

# 자료구조
- 자료구조란 논리적으로 설계된 데이터 구조임
- 데이터용량과 실행시간을 최소한으로 해야함
- 단순 구조, 선형 구조, 비선형 구조, 파일구조 등이 있음
    - 단순 구조 : 정수나 실수, 문자등의 데이터임
    - 선형 구조 : 데이터들의 대응관계가 1대1인 경우임 순차,연결로 나뉨, 스택, 큐, 데크, 선형 리스트, 연결리스트가 있음
        - 순차 구조 : 데이터 탐색 속도가 우선임
        - 연결 구조 : 데이터 이동이 우선임
    - 비선형 구조 : 데이터의 대응관계가 1대다인경우임, 트리,그래프가 있음
    - 파일 구조 : 보조기억장치에 실제로 데이터가 기록될 때 활용함, 순차파일, 직접파일, 색인순차파일 등이 있음
**탐색**
- 탐색은 원하는 데이터를 찾는거임
- 내부탐색, 외부탐색으로 나뉨
    - 내부 탐색 : 주기억 장치(cpu) 탐색, 적은 양의 데이터를 빠르게 탐색
    - 외부 탐색 : 주기억, 보조기억장치 함께 탐색, 많은 양을 느리게 탐색
- 종류가 꽤 많음
    - 선형 탐색 : 대상 데이터를 처음부터 순차적으로 비교해서 탐색
        - **정렬이 안되도 사용가능**
        - 데이터 수가 적을때 활용 가능함
        - N개의 데이터를 가진 자료구조의 선형탐색 평균비교횟수 : (N+1)/2
        - 시간복잡도는 최악의 경우를 보여주기에 O(N)임
    - 이분 탐색 : 대상 데이터를 절반씩 나누어서 탐색
        - **정렬이 되어야만 사용가능**
        - 데이터 개수 파악, 데이터 정렬이 반드시 되어야함
        - 시간복잡도는 O(logN)
    - 보간 탐색 : 찾을 값의 위치값을 예상해서 검색하는 사전식 탐색
        - 시간 복잡도는 O(log(logN))임
    - 블록 탐색 : 대량의 데이터를 그룹별로 블록화 해서 인덱싱을 통해 탐색
        - N개의 데이터를 가진 자료의 가장 이상적인 블록갯수는 N임
        - 블록별 가장 큰값을 써서 인덱스를 생성
        - 블록 내부 데이터는 다음 블록 최소값보다 작아야함
        - 내부 요소는 **정렬안해도 됨**
    - 이진 트리 탐색 : 검색 대상 데이터를 이진 트리로 변형한 뒤에 탐색
        - 시간 복잡도는 O(logN)임
    - 해싱 탐색 : 해싱 함수를 사용하여 데이터 탐색
        - 어떤 해시 함수를 사용해야하는지가 문제로 나옴
        - 시간 복잡도는 O(1)임
        - 해싱 함수를 통해 결정된 저장 위치가 충돌(중복)할 경우에는 조치가 필요함
        - 관련 용어들
            - 해시 테이블은 홈 주소와 버킷,슬롯으로 구성됨
            - 해싱 함수는 키를 입력받아 계산한 결과를 데이터가 저장될 홈 주소로 사용함
            - 홈 주소 : 해시 테이블의 내부 인덱스
            - 키 : 데이터 레코드 중 해싱 함수의 입력값이 되는 데이터
            - 버킷 : 슬롯들의 집합, 하나의 홈 주소에 여러개가 존재가능
            - 슬롯 : 하나의 데이터를 저장할 수 있는 공간
            - 해시 테이블 : 다수의 홈 주소와 버킷으로 구성된 기억 공간, 해시 함수의 참조 대상
            - 동의어(Synonym) : 충돌이 일어난 슬롯의 집합
            - 충돌(Collision) : 서로 다른 슬롯이 같은 키를 가지는 현상
            - 프로빙 : 충돌이 발생한 데이터를 다음 버킷(1차)이나 멀리 떨어진 버킷으로 이동
            - 체인법 : 오버플로우 해결을 위해 슬롯을 연결리스트 형태로 연결함 
        - 해시 함수의 종류
            - 제산법 : 키를 특정 값으로 나눈 나머지 값을 이용해 저장 위치를 결정함
            - 폴딩법 : 키를 여러 부분으로 나누어 부분별 순차의 합연산, XOR연산의 결과로 저장 위치 결정
            - 제곱법 : 키를 제곱한 결과의 일부분으로 저장 위치 결정
            - 숫자 분석법 : 키의 숫자 분포가 고른 부분을 분석하여 저장 위치 결정
            - 기수 변환법 : 키의 값을 다른 진법으로 변환하여 저장 위치 결정
            - 무작위법 : 난수를 이용하여 저장 위치를 결정
        - 해시 함수는 충돌을 최소화할 수 있어아만 함
**시간 복잡도**
- 탐색과 같은 알고리즘을 수행할 때, 연산이 수행되는 횟수를 나타냄
- 일반적으로 빅오(O)표기법을 이용함 
- O(1) : 데이터 수와는 관계없이 **일정한 수행 횟수**를 가지는 최고의 알고리즘임 여기서 1은 한번만 수행하는게 아니라 고정적인 연산 횟수라는 뜻
- O(logN) : 데이터 수에 따라 연산 횟수가 늘어나는 폭이 점점 줄어듬, 이분탐색, 이진트리탐색에 사용함
- O(N) : 데이터 수에 따라서 연산 횟수가 일정하게 증가(비례)함, 선형 시간 알고리즘이라고 부름, 수열이나 순차 탐색에 사용함
- O(NlogN) : 데이터 수에 따라서 연산 횟수가 늘어나는 폭이 점점 커짐,
퀵 정렬, 힙 정렬, 병합 정렬에 사용함 
- O(N^2) : 데이터 수에 따라서 연산 횟수가 데이터 수의 제곱만큼 필요함, 버블 정렬, 선택 정렬에 사용함, 비효율적이지만 구현이 쉬워서 많이 씀
- O(2^N) : 데이터 수에 따라서 연산 횟수가 데이터 수의 지수승만큼 필요함, 재귀 호출에 사용함
- O(N!) : 데이터 수에 따라 연산 횟수가 데이터 수의 팩토리얼만큼 필요함, 가장 느린 알고리즘임, 입력값이 조금만 증가해도 계산이 힘듬

**정렬**
- 데이터를 순서대로 나열하는거임
- 오름차순은 1234 처럼 수가 커짐
- 내림차순은 4321 처럼 수가 작아짐
    - 선택 정렬 : 정렬 대상 중에서 기준값으로 선택된 데이터(보통 맨앞)를 나머지랑 비교함
        - 선택 데이터 > 나머지 데이터 최소값이면 바꿈
        - 선택 데이터 < 나머지 데이터 최소값이면 유지함
        - 정렬이 끝나면 첫번째에는 가장 작은값이 와야함 이거 빼고 반복해서 반복함
        - 반복할 때마다 시작되는 위치는 계속 증가함
        - 시간 복잡도는 (N^2)임 
    - 버블 정렬 : 기준값으로 지정한 값이랑 바로 다음값만 비교함
        - 기준값 > 오른쪽이면 바꿈
        - 기준값 < 오른쪽이면 유지함
        - 정렬이 끝나면 오른쪽에 가장 큰데이터가 와야함 이거 빼고 다시 반복함
        - 반복할 때마다 종료되는 위치가 감소함
        - 시간 복잡도는 O(N^2)임
    - 삽입 정렬 : 정렬 대상 중에서 좌측에 이미 정렬된 요소랑 비교해서 자신의 위치를 찾아서 삽입함
        - 두번째부터 시작함
        - 데이터 삽입하면 나머지는 오른쪽으로 밀려남
        - 시간 복잡도는 O(N^2)임
    - 쉘 정렬 : 삽입정렬 보완형임, 데이터 간격을 정하고 간격을 줄이면서 삽입정렬을 진행함
        - N개의 데이터를 가진 자료구조의 간격을 구하는 공식 : 1.72^3루트3
        - 데이터 수가 적거나 보편적 상황에서 공식 : N/2
    - 힙 정렬 : 정렬 대상을 완전 이진트리로 만들어서 정렬함
        - 자식노드가 부모노드가 크면 자료를 교환함
        - 최대값, 최소값을 비교적 쉽게 추출할 수 있음
        - 시간 복잡도는 항상 O(NlogN)임
    - 이진 병합 정렬 : 두 데이터를 한 쌍으로 병합하여 정렬하고, 정렬된 두 그룹을 다시 한쌍으로 만들어서 정렬을 반복함
    - 버킷 정렬 : 정렬 대상의 데이터 범위를 균등하게 나눈 여러 버킷을 만들어서 정렬함, 스택을 사용함, 데이터 범위 파악이 되야만 함
    - 퀵 정렬 : 기준값을 기준으로 2개의 비균등(같은값이 아닌) 크기의 배열로 분할해서 정렬함
        - 분할 정복 알고리즘을 적용해서 매우 빠름
        - 기준값을 이상적으로 선택하면 NlogN이지만 **최악은 O(N^2)임**
        - 분할 : 기준값(pivot)을 기준으로 큰 값은 오른쪽, 작은 값은 왼쪽의 부분 배열로 분할함
        - 정복 : 부분 배열을 다시 분할, 적절한 크기가 되면 정렬함
        - 결합 : 정렬된 부분 배열들을 하나로 결합함

## 연계 데이터 구성
**통합 구현 개념**
- 통합 구현은 사용자 요구사항을 해결하기 위한 새로운 서비스 창출을 위해서 모듈간의 연계와 통합을 구성하는 것임
- 주로 송수신 시스템, 중계 시스템 및 연계 데이터와 네트워크가 있음
**송신시스템**
- 전송하고자 하는 데이터를 생성함
- 일반적으로는 데이터 생성 처리만 구현해놓음
**중계시스템**
- 내외부 시스템간의 연계할때 씀
- 송신시스템에서 받아서 수신시스템으로 보내주는 역할임
- 구간을 분리함으로써 보안성이 강화되고 인터넷 망을 연결할 수 있음
- 주로 데이터의 오류 처리나 데이터 변환, 매핑을 처리하는 역할임
**수신시스템**
- 중계시스템에게서 데이터를 받아서 처리함
**연계데이터**
- 송수신할때 쓰는 데이터를 연계데이터라고 함
- 속성,길이,타입 등이 포함되어 있음
- 표준화 절차
    - 연계 범위 및 항목 정의 > 연계 코드 매핑 및 정의 > 변경된 데이터 구분방식 정의 > 데이터 연계 방식 정의
    - 연계 범위 및 항목 정의 : 시스템 간 연계하려는 정보를 상세화함
    - 연계 코드 매핑 및 정의 : 코드로 관리해야하는 항목을 변환함, 주로 송신코드를 수신코드로 매핑, 송수신시스템에서 사용하는 코드 표준화 후 매핑이 있음
    - 변경된 데이터 구분방식 정의 : 정의와 표준화가 완료된 정보를 시스템에 반영하기 위해 연계 데이터 식별자와 변경 구분을 추가함, 추가되는 정보는 식별자, 변경구분, 관리정보가 있음
        - 식별자(primary key) : 데이터를 유일하게 식별할 수 있는 이름
        - 변경 구분: 송신 정보를 수신 시스템의 테이블에 어떻게 반영(추가,수정,삭제)할지 식별함
        - 관리 정보 : 연계 정보의 송수신 여부, 일시, 오류 코드 등의 모니터링을 위한 벙보
    - 연계 데이터 표현방식 정의 : 연계 데이터를 테이블이나 파일의 형식으로 구성함, 파일로 구성하면 파일 형식에 따라서 상세화 함
        - XML, JSON, TEXT 등이 있음
        - XML : 사용자가 임의로 생성한 태그를 통해 상세화
        - JSON : XML을 대체하는 독립적인 자바스크립트 기반 표준형식임 AJAX기술에서 많이 씀
        - TEXT형식 : 항목 분리자(콤마,콜론,세미콜론) 등을 통해 상세화함
    