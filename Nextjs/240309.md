# TIL 240308 NEXTjs 메모

## 리액트 쿼리 왜씀?
- 일단 상태에는 두가지가 있음 client state, server state

# server state
- 서버는 특정 시점에 클라이언트의 요청에 대해 데이터 베이스에서 유저 정보를 가져와 서버의 상태 값을 만듬
- 데이터 베이스에 있는 값을 그대로 클라이언트에게 전달 할 수도 있음
- 요청에 담긴 특정 값을 이용해 정보를 가공 해서 메모리에 들고 있게 됨 
- 이 정보들을 클라언트들에게 전달해줌 
- 이게 서버스테이트

# client state
- 클라이언트 스테이트는 2개로 나뉨
- 클라이언트에서 **자체적으로 만듬**(데이터 발생지가 클라이언트임)
- 이 데이터는 UI를 담당하는, 모달이 열리거나 하는등의 데이터 상태값임
- **서버에서 전달받은 값**으로 만듬(데이터 발생지가 서버임)
- 일반적으로 서버의 상태값을 받아오는건 모범답안이 없음
- 왜냐면 컴포넌트의 생명주기를 파악하고 적절한 시점에 ajax호출 후, 서버에서 데이터를 받아오기 때문임
- useState를 사용하면 데이터를 불러와서 setState 호출을 통해서 응답 당시의 server state를 component state로 wrapping함
``
useEffect(() => {
 customFetch("...").then(setState)
},[]);
``
- 이런 식으로
- 이러면 클라이언트 앱은 server state와 client state에 대한 로직 처리를 나누어서 선언해야함

# 문제 해결
- server state의 쉬운 수급
- 앱이 간편하면 상관없지만 앱이 복잡해질때 쓰면 좋음
- 리액트 쿼리는 hook기반의 로직들로 되어있음
- 그래서 해당 훅을 사용하는 컴포넌트에서 상태값의 변경을 간편하게 파악해서 리렌더링 해줌
- 이는 즉 server state를 간편하게 수급한다는 뜻이 됨
- 캐시
- 리액트 쿼리가 나오기 전까지는 state는 암묵적으로 client state만 카르키는거였음
- 만약 주식이나 코인거래소같은 어플리케이션이 있다면
- 이미 사용된 데이터는 10초뒤에 휴지가 되버림
- 이러면 클라이언트에선 polling 방식으로 주기적으로 데이터를 받아오거나(setInterval방식) 웹소켓을 통해 서버의 상태를 관리해줘야함.
- 이러면 또 api서버에 추가 작업을 해줘야함
- 또한 A페이지의 특정 컴포넌트에서 부른 데이터를 페이지 전환해서 B페이지에서 재사용하려면
- A,B 페이지에선 state store에 해당 데이터가 이미 존재하는지에 대한 로직이 각기 들어가야함(재호출방지)
- 해당 데이터의 유효성에 대한 로직을 추가 작성해야함.
- 쉽게 말하면 유저가 탭을 이동했다가 다시 돌아왔을 때
- 최초 접속한지 몇초 지난 이후에는 데이터가 만료되었다고 판단
- 리렌더링하는 로직을 추가로 또 써야함
- 대신 리엑트 쿼리는 데이터의 캐시처리를 간편하게 할수있는 인터페이스를 제공함
- 몇 초 이후에는 데이터가 유효하지 않은 것으로 간주하고 데이터를 다시 불러옴
- 데이터에 변경점이 있는 경우에만 리렌더링을 유발함
- 유저가 탭을 이동했다가 다시 돌아왔을 때 데이터를 다시 불러옴
- 데이터를 다시 호출할때 응답이 오기 전까지는 이전 데이터를 계속 보여줌
- 필요에 따라서는 로딩바와 같은 대안 UI를 보여주기 위해 loading state를 기본적으로 제공함
- 위와같은 기능들이 있음
- fetch api 쓸때 에러처리 불편해서 axios 쓰는거처럼
- **클라이언트와 서버의 상태값을 일치시켜야하는 요구사항에서 부가적으로 생길 수 있는 로직을 리액트쿼리의 api와 인터페이스로 해결할 수 있음**

## 리덕스 왜씀?
- state 겹치는거 props로 주면 어지러우니까 
- state를 기록해놓는 store를 만들어서 한번에 관리하려고